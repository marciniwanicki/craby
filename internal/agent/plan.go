package agent

import (
	"encoding/xml"
	"fmt"
	"regexp"
	"strings"
)

// Complexity represents the complexity level of a plan
type Complexity string

const (
	ComplexitySimple    Complexity = "simple"
	ComplexityTool      Complexity = "tool"
	ComplexityMultiStep Complexity = "multi_step"
)

// Plan represents a structured plan generated by the LLM
type Plan struct {
	XMLName       xml.Name   `xml:"plan"`
	Intent        string     `xml:"intent"`
	Complexity    Complexity `xml:"complexity"`
	NeedsTools    bool       `xml:"needs_tools"`
	ReadyToAnswer bool       `xml:"ready_to_answer"` // True when we have enough info to synthesize
	Context       []string   `xml:"context>item"`
	Steps         []PlanStep `xml:"steps>step"`
}

// PlanStep represents a single step in the plan
type PlanStep struct {
	ID        string    `xml:"id,attr"`
	DependsOn string    `xml:"depends_on,attr"`
	Tool      string    `xml:"tool"`
	Purpose   string    `xml:"purpose"`
	Args      []PlanArg `xml:"args>arg"`
}

// PlanArg represents an argument for a tool call
type PlanArg struct {
	Name  string `xml:"name,attr"`
	Value string `xml:",chardata"`
}

// ArgsMap converts the slice of PlanArg to a map
func (s *PlanStep) ArgsMap() map[string]any {
	args := make(map[string]any, len(s.Args))
	for _, arg := range s.Args {
		args[arg.Name] = strings.TrimSpace(arg.Value)
	}
	return args
}

// planTagRegex matches the <plan>...</plan> content
var planTagRegex = regexp.MustCompile(`(?s)<plan>(.*?)</plan>`)

// ParsePlan extracts and parses the plan XML from LLM response content
func ParsePlan(content string) (*Plan, error) {
	// Find the <plan>...</plan> block
	matches := planTagRegex.FindStringSubmatch(content)
	if len(matches) < 2 {
		return nil, fmt.Errorf("no <plan> block found in response")
	}

	// Reconstruct the full XML for parsing
	planXML := "<plan>" + matches[1] + "</plan>"

	var plan Plan
	if err := xml.Unmarshal([]byte(planXML), &plan); err != nil {
		return nil, fmt.Errorf("failed to parse plan XML: %w", err)
	}

	// Validate complexity
	switch plan.Complexity {
	case ComplexitySimple, ComplexityTool, ComplexityMultiStep:
		// Valid
	default:
		return nil, fmt.Errorf("invalid complexity: %q", plan.Complexity)
	}

	// Validate that needs_tools matches steps (unless ready to answer)
	if plan.NeedsTools && len(plan.Steps) == 0 && !plan.ReadyToAnswer {
		return nil, fmt.Errorf("needs_tools is true but no steps provided (and not ready_to_answer)")
	}

	return &plan, nil
}
